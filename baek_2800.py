# Python

## baek 2800 괄호제거

https://www.acmicpc.net/problem/2800



> 120ms



* 문제

  > 어떤 수식이 주어졌을 때, 괄호를 제거해서 나올 수 있는 서로 다른 식의 개수를 계산하는 프로그램을 작성하시오.
  >
  > 이 수식은 괄호가 올바르게 쳐져 있다. 예를 들면, 1+2, (3+4), (3+4*(5+6))와 같은 식은 괄호가 서로 쌍이 맞으므로 올바른 식이다.
  >
  > 하지만, 1+(2*3, ((2+3)*4 와 같은 식은 쌍이 맞지 않는 괄호가 있으므로 올바른 식이 아니다.
  >
  > 괄호를 제거할 때는, 항상 쌍이 되는 괄호끼리 제거해야 한다.
  >
  > 예를들어 (2+(2*2)+2)에서 괄호를 제거하면, (2+2*2+2), 2+(2*2)+2, 2+2*2+2를 만들 수 있다. 하지만, (2+2*2)+2와 2+(2*2+2)는 만들 수 없다. 그 이유는 쌍이 되지 않는 괄호를 제거했기 때문이다.
  >
  > 어떤 식을 여러 쌍의 괄호가 감쌀 수 있다.

* 입력

  > 첫째 줄에 음이 아닌 정수로 이루어진 수식이 주어진다. 이 수식은 괄호가 올바르게 쳐져있다. 숫자, '+', '*', '-', '/', '(', ')'로만 이루어져 있다. 수식의 길이는 최대 200이고, 괄호 쌍은 적어도 1개, 많아야 10개이다. 
  >
  > ```bash
  > (0/(0))
  > ```

* 출력

  > 올바른 괄호 쌍을 제거해서 나올 수 있는 서로 다른 식을 사전 순으로 출력한다.
  >
  > ```bash
  > (0/0)
  > 0/(0)
  > 0/0
  > ```



```python
from itertools import combinations

bracket = list(input()) # [*input()] 으로도 바꿀 수 있음, 문자열 담기
open = [] # 여는 괄호 인덱스 담기
idx = [] # 닫힌 괄호가 있으면 여는 괄호와 동시에 담아주기
for i,j in enumerate(bracket): # enumerate 속도 차이 비교, 이뉴머레이트 안써도 시간차이 별로 아난긴 한다. 고작 4ms,,?
    if j == '(': # 여는 괄호라면
        open.append(i) # 여는 괄호 리스트에 넣고
        bracket[i] = '' # 그자리를 공백으로 넣는다.
    if j == ')': # 닫힌 괄호라면
        idx.append([open.pop(),i]) # 여는 괄호를 팝해서 인덱스 리스트에 넣는다.
        bracket[i] = '' # 그리고 역시 그자리도 공백으로
result = set() # 중복을 배제할 set
for i in range(len(idx)): # 저장된 인덱스 길이에 따라
    for j in combinations(idx,i): # 조합으로 구성한다.
        tmp = bracket[:] # 매번 새로운 리스트로 조합을 구성하기 위해 초기화.
        for m,n in j: # 인덱스를 m n에 넣고
            tmp[m] = '(' # 공백으로 처리한 부분에
            tmp[n] = ')' # 다시 괄호를 채워준다.
        result.add(''.join(tmp)) # 하나로 만들고 set에 넣어준다.
for i in sorted(result): # set은 정렬이 안되기 때문에, (정렬 뿐만 아니라 append도 안된다.) 이렇게 sorted함수를 쓰면서 출력해 줘야 한다.
    print(i)
```

> 내가 당황했던 거는 어떻게 조합으로 이걸 구성하느냐였는데, 인덱스를 리스트를 담는 게 중요해 보였다. 그리고 시간을 줄이기 위한 갖은 시도를 해보았다. 
>
> 중간에
>
> __tmp = bracket[:]__ : 왜 이렇게 해야 하는지 몰랐다. tmp = bracket으로 하면 왜 값이 뒤집어 씌워지지 않는지 찾아봤는데 알고보니 메모리 값을 이미 같이 공유하고 있기 때문에 tmp값을 변경하면 bracket 값도 바뀐다고 한다. 그래서 다시 원래의 값으로 돌아갈 수 없는 거라고,, 슬라이싱을 사용하면 기존의 값은 바뀌지 않는데, 사실 이것도 약한 복사라고 해서 append로 값을 추가한다면 기존의 리스트도 바뀐다.



* 모범답안

  ```python
  
  ```

  > 모범답안 보고 따라한 거라 딱히 모범답안은 없음